# -*- coding: utf-8 -*-
"""백준 6588 (골드바흐의 추측)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dk3IzUe5bkgTfbDC6ZBlk4LkPI8spUa3

#에라토스테네스의 체
---

- 지워지지 않은 수 중에서 가장 작은 수의 배수들을 모두 지워가라..

- dp를 이용해서 주어진 수의 제곱근까지만 가장 작은수를 확인하면 된다..

- 이 문제는 import sys까지 해야된다..

**중요포인트**

- dp를 최댓값까지 뭐가 소수인지를 확인해 놓는것이 시간을 줄인다
"""

#아예 모든 입력에 대해서 소수를 구해놓는다..
dp = [False, False] + [True]*(999999)

#배수를 빼는 과정을 주어진 수의 제곱근까지만 하면 된다..
for i in range(2,int(1000000**0.5) + 1):
    if dp[i]:
        #소수들의 배수를 다 빼는 과정..
        for j in range(2*i, 1000000, i):
            dp[j] = False

while 1:
    n = int(input())
    if n == 0:
         break
    mid = n//2
    
    for k in range(3, mid +1):
        if dp[k] and dp[n-k]:
            break
    print(f"{n} = {k} + {n-k}")

#다른 사람 거..
#람다함수를 사용해서 가져왔다..

import sys
input = lambda : sys.stdin.readline().strip()

num = 1000000
prime = [False,False] + [True] * num

for i in range(2, num + 1) :
    if prime[i] :
        for j in range(i * 2, num + 1, i) :
            prime[j] = False

while True :
    n = int(input())
    if n == 0 :
        break

    for i in range(num) :
        if prime[i] and prime[n - i] :
            print(n, '=', i, '+', n - i)
            break
    else :
        print('Goldbach\'s conjecture is wrong.')

# 무지했던 옛날의 나..

import sys

def IsPrime(n):
    if n == 3:
        return True
    else :
        Isprime = True
        for i in range(2,int(n**1/2)+1):
            if n % i == 0 :
                Isprime = False
                break
        return Isprime
def IsPrime_dp(n):
    dp = [False, False] + [True]*(n-1)
    for i in range(2,n):
        for j in range(2*i, n, i):
            dp[j] = False

while 1:
    n = int(sys.stdin.readline())
    if n == 0:
         break
    else:
        mid = n // 2
        for i in range(3, mid+1):
            if IsPrime(i) and IsPrime(n-i):
                break
        print(f"{n} = {i} + {n-i}")

#테스트케이스를 여러개를 어떻게 받냐...