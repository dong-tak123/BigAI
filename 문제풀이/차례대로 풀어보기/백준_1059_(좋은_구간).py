# -*- coding: utf-8 -*-
"""백준 1059 (좋은 구간)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cVATDPRwJKxzi1vCXYFY_g7rVYJQtfOh

**좋은구간**

- A와 B는 양의 정수이고, A < B를 만족한다.
- A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.

크기 L이 주어지고 밑에는 집합 S가 주어진다

마지막으로 꼭 포함해야할 n이 주어진다

**풀이**
- 입력 S을 정렬시킨다
- S의 길이가 1일 때를 대비하여 젤 앞에 0을 추가시키고 길이 L을 1 더해준다
    - 그 이유는 최소를 찾을 때 인덱스 에러를 예방하기 위함도 있다
- for 문을 돌려서 입력 n이 어느 구간 안에 있는지 찾는다
- 나올 수 있는 좋은 구간의 수를 계산한다
"""

L = int(input())
S = list(map(int, input().split()))
n = int(input())

S.sort()
# n이 어디 사이에 있는지 알아내자
# 큰거를 찾아야지 제대로 나온다..
found = False
for i in range(L):
    if S[i] == n:
        found = True
        break

if found :
    print(0)
else:  
    #이제 어딘지 확인해야함..
    #L이 1일 때를 대비한 0 투입, L도 1 증가 시킴
    S.insert(0,0)
    L += 1
    #새로운 변수에 저장한다..
    for i in range(L):
        if S[i] < n:
            min = S[i]
        elif S[i] > n:
            max = S[i]
            break
    # S[i] < n < S[i+1] 의 관계가 있음..
    print((max - n) * (n - min) - 1)

"""
- 인덱스 에러가 발생..
- 각 포문(여기서는 while문)에서 한 인덱스 씩만 비교해 줘야함
"""

L = int(input())
S = list(map(int, input().split()))
n = int(input())

S.sort()
# n이 어디 사이에 있는지 알아내자
# 큰거를 찾아야지 제대로 나온다..

found = False
for num in S:
    if num == n:
        found = True
        break

if found:
    print(0)
else:
    if L == 1:
        print(n * (S[0] - n) -1)
    else:
        for i in range(L-1):
            if S[i] < n < S[i+1]:
                min = S[i]
                max = S[i+1]
                break
        # S[i] < n < S[i+1] 의 관계가 있음..
        print((max - n) * (n - min) - 1)

