# -*- coding: utf-8 -*-
"""백준 2581 (소수)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1owTj0Mw8m7c_oJI_Bi7ht60CHUMnsR8T

**문제**

- M과 N이 주어진다
- 두 수 사이의 소수의 합을 출력한다

**풀이**

- 소수임을 판별하는 dp를 만든다
- 소수의 갯수를 cnt로 확인하면서 최소값을 찾는다..
- cnt를 확인하는 cnt가 2 이상이면 불필요한 루프를 돌기 때문에 낭비가 있다
- 이를 sum의 값을 이용해 확인 할 수 있다
"""

"""
cnt를 이용한 최댓값 찾기
"""

M = int(input())
N = int(input())

Is_Prime = [False, False] + [True]*(N-1)
for i in range(2, N+1):
    if Is_Prime[i]:
        for j in range(2*i, N+1, i):
            Is_Prime[j] = False

cnt = 0
sum = 0
for k in range(M, N+1):
    #합 구하기
    if Is_Prime[k]:
        sum += k
        cnt += 1
    if cnt == 1 and Is_Prime[k]:
        min = k

if sum > 0:
    print(sum)
    print(min)
else:
    print(-1)

"""
sum값을 이용한 최솟값 찾기
"""

M = int(input())
N = int(input())

Is_Prime = [False, False] + [True]*(N-1)
for i in range(2, N+1):
    if Is_Prime[i]:
        for j in range(2*i, N+1, i):
            Is_Prime[j] = False

cnt = 0
sum = 0
for k in range(M, N+1):
    #합 구하기
    if Is_Prime[k]:
        sum += k
        #sum을 이용해서 확인해보자..
        if sum == k:
            min = k

if sum > 0:
    print(sum)
    print(min)
else:
    print(-1)

